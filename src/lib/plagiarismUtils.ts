
import type { PlagiarismResult } from "@/components/PlagiarismChecker";

// This function would typically make an API call to a plagiarism detection service
export const detectPlagiarism = async (text: string): Promise<PlagiarismResult> => {
  // In a real implementation, this would call an external API
  // For demo purposes, we're generating mock data
  
  // Generate a random plagiarism score between 5 and 75
  const plagiarismScore = Math.floor(Math.random() * 70) + 5;
  
  // Get some random segments from the text to highlight as "plagiarized"
  const words = text.split(/\s+/);
  const highlightedSegments: string[] = [];
  const matchedSources: PlagiarismResult["matchedSources"] = [];
  
  // Exit early if text is too short
  if (words.length < 20) {
    return {
      originalText: text,
      plagiarismScore: 0,
      matchedSources: [],
      highlightedText: text,
    };
  }
  
  // Generate 0-3 "plagiarized" segments based on plagiarism score
  const numSegments = plagiarismScore > 50 ? 3 : plagiarismScore > 20 ? 2 : plagiarismScore > 5 ? 1 : 0;
  
  for (let i = 0; i < numSegments; i++) {
    // Pick a random starting position in the text
    const startPos = Math.floor(Math.random() * (words.length - 10));
    // Get a segment of 5-10 words
    const segmentLength = Math.floor(Math.random() * 5) + 5;
    const segment = words.slice(startPos, startPos + segmentLength).join(' ');
    
    highlightedSegments.push(segment);
    
    // Generate a mock source
    const domains = [
      "wikipedia.org/wiki/article", 
      "academic-papers.edu/research", 
      "essays-online.com/sample", 
      "scholarly-articles.org/publication",
      "researchgate.net/publication"
    ];
    
    const randomDomain = domains[Math.floor(Math.random() * domains.length)];
    
    matchedSources.push({
      url: `https://${randomDomain}${i}`,
      matchedText: segment,
      confidence: Math.floor(Math.random() * 30) + 70, // 70-99% confidence
    });
  }
  
  // Highlight the "plagiarized" segments in the text
  let highlightedText = text;
  highlightedSegments.forEach(segment => {
    highlightedText = highlightedText.replace(
      segment, 
      `<span class="highlighted-text">${segment}</span>`
    );
  });
  
  return {
    originalText: text,
    plagiarismScore,
    matchedSources,
    highlightedText,
  };
};

// Generate a downloadable report
export const generateReport = (result: PlagiarismResult): Blob => {
  // In a real implementation, this would generate a PDF
  // For demo purposes, we're returning a simple text file
  
  const { plagiarismScore, matchedSources, originalText } = result;
  
  const reportContent = `
    PLAGIARISM DETECTION REPORT
    Generated on: ${new Date().toLocaleDateString()}
    
    OVERALL PLAGIARISM SCORE: ${plagiarismScore}%
    
    ORIGINAL TEXT:
    ${originalText}
    
    ${matchedSources.length > 0 ? 'MATCHED SOURCES:' : 'NO MATCHED SOURCES FOUND'}
    ${matchedSources.map((source, i) => `
    Source ${i + 1}: ${source.url}
    Confidence: ${source.confidence}%
    Matched text: "${source.matchedText}"
    `).join('\n')}
    
    This report was generated by Copy Cat Catcher Pro.
  `;
  
  return new Blob([reportContent], { type: 'text/plain' });
};
